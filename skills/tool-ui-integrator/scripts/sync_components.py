#!/usr/bin/env python3
"""Sync Tool UI component metadata for this skill.

Generate:
- references/components-data.json
- references/components-catalog.md

Source of truth:
- lib/docs/component-registry.ts
"""

from __future__ import annotations

import argparse
import json
import re
from pathlib import Path

CATEGORY_LABELS = {
    "progress": "Progress",
    "input": "Input / Decision",
    "display": "Display",
    "artifacts": "Artifacts",
    "confirmation": "Confirmation",
    "media": "Media",
}

CATEGORY_ORDER = ["progress", "input", "display", "artifacts", "confirmation", "media"]


def parse_registry(source_path: Path) -> list[dict[str, str]]:
    text = source_path.read_text()

    array_match = re.search(
        r"export const componentsRegistry:\s*ComponentMeta\[]\s*=\s*\[(?P<body>.*?)\n\];",
        text,
        flags=re.DOTALL,
    )
    if not array_match:
        raise ValueError("Could not locate componentsRegistry array in source file")

    body = array_match.group("body")
    object_pattern = re.compile(
        r"\{\s*"
        r'id:\s*"(?P<id>[^"]+)",\s*'
        r'label:\s*"(?P<label>[^"]+)",\s*'
        r'description:\s*"(?P<description>[^"]+)",\s*'
        r'path:\s*"(?P<path>[^"]+)",\s*'
        r'category:\s*"(?P<category>[^"]+)",\s*'
        r"\}",
        flags=re.DOTALL,
    )

    components = [m.groupdict() for m in object_pattern.finditer(body)]
    if not components:
        raise ValueError("No components parsed from registry source")

    return sorted(components, key=lambda c: c["id"])


def render_catalog(components: list[dict[str, str]]) -> str:
    by_category: dict[str, list[dict[str, str]]] = {key: [] for key in CATEGORY_ORDER}
    for comp in components:
        category = comp["category"]
        if category in by_category:
            by_category[category].append(comp)

    lines: list[str] = []
    lines.append("# Tool UI Component Catalog")
    lines.append("")
    lines.append("This file is generated by `scripts/sync_components.py`.")
    lines.append("Do not edit manually.")
    lines.append("")

    for category in CATEGORY_ORDER:
        items = by_category.get(category, [])
        if not items:
            continue

        lines.append(f"## {CATEGORY_LABELS[category]}")
        lines.append("")
        for comp in items:
            lines.append(f"- `{comp['id']}`: {comp['description']}")
        lines.append("")

    lines.append("## Selection Heuristics")
    lines.append("")
    lines.append("- Need a user decision with explicit confirm action: start with `option-list` or `approval-card`.")
    lines.append("- Need ongoing task status: use `plan` for ordered steps, `progress-tracker` for live execution.")
    lines.append("- Need compact KPIs: use `stats-display`; for rows and columns use `data-table`.")
    lines.append("- Need social content previews: use `instagram-post`, `linkedin-post`, or `x-post`.")
    lines.append("")

    return "\n".join(lines)


def write_outputs(
    components: list[dict[str, str]],
    data_out: Path,
    catalog_out: Path,
) -> None:
    data_out.parent.mkdir(parents=True, exist_ok=True)
    data_out.write_text(json.dumps(components, indent=2) + "\n")

    catalog_out.parent.mkdir(parents=True, exist_ok=True)
    catalog_out.write_text(render_catalog(components))


def default_source_path() -> Path:
    script_path = Path(__file__).resolve()
    return script_path.parents[4] / "lib" / "docs" / "component-registry.ts"


def main() -> None:
    skill_root = Path(__file__).resolve().parents[1]

    parser = argparse.ArgumentParser(description="Sync Tool UI skill component metadata")
    parser.add_argument(
        "--source",
        default=str(default_source_path()),
        help="Path to lib/docs/component-registry.ts",
    )
    parser.add_argument(
        "--data-out",
        default=str(skill_root / "references" / "components-data.json"),
        help="Output JSON file for component metadata",
    )
    parser.add_argument(
        "--catalog-out",
        default=str(skill_root / "references" / "components-catalog.md"),
        help="Output markdown catalog",
    )
    args = parser.parse_args()

    source_path = Path(args.source).resolve()
    if not source_path.exists():
        raise SystemExit(f"Source file not found: {source_path}")

    components = parse_registry(source_path)
    write_outputs(components, Path(args.data_out).resolve(), Path(args.catalog_out).resolve())

    print(f"Synced {len(components)} components")
    print(f"- {Path(args.data_out).resolve()}")
    print(f"- {Path(args.catalog_out).resolve()}")


if __name__ == "__main__":
    main()
